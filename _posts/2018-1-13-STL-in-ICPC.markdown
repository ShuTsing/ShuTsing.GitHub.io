---
layout:     post
title:      "C++ STL在ACM中的应用"
subtitle:   "C++ STL in ACM-ICPC"
date:       2018-01-13 13:12:00
author:     "ShuTsing"
header-img: "img/post-bg-17.jpg"
header-mask: 0.3
catalog:    true
tags:
    - STL
    - 算法
    - C++
---

## 写在前面  
### 什么是STL？  
STL是 Standard Template Library 的简称，中文名为标准模板库，是惠普实验室开发的一系列软件的统称。（从百度百科抄的  
MSVC，clang和gcc等编译器厂商都会根据C++标准委员会制定的STL标准自行编写STL，但是基本都是基于最早惠普实验室开发的这个版本。  
### 为什么要在竞赛中使用STL？  
STL给我们提供了很多算法竞赛中经常使用到的算法和数据结构，如：

- 提供的算法：快速排序，全排列，二分搜索……  
- 提供的数据结构：动态数组，二叉排序树，优先队列……  

灵活使用这些STL中的算法和数据结构可以有效避免在比赛中重复造轮子，加快代码的编写速度，同时避免出现Bug。

基于以上原因，算法选手需要能够较好的将STL作为黑盒使用，并了解其提供的操作以及操作的时间复杂度。  

但是我在接下来还是会稍微讲一下STL的原理以期能更好的应用。  
### 为STL运行效率申冤  
很多高中打过某O字开头的竞赛的同学（包括我）都对STL的运行效率有一种固有的低下的印象。  
我个人认为可能有下列三点原因：  

- 某O字开头的竞赛在编译时不开编译器优化
- 对语言为了实现多态而影响运行效率的印象
- 某些选手在使用中没有选用合适的容器和方法（函数）

事实上，对于一个发行版本的程序来说，基本上是一定会开编译器优化的，如果不开编译器优化则一般是在调试阶段。ACM-ICPC还是给了选手发布Release版本的机会的（笑）即开-O2优化。  
而STL出于工程上的考虑，在debug状态下会进行诸多安全性检查和验证。    

一般来说，通过虚函数和继承来实现的运行期多态确实会影响运行效率，某J字开头的语言所提供的泛型本质上是个语法糖，还是实现的运行期多态。  
然而C++用以实现泛型编程的Template（模板）则是编译器多态，在编译时就会确定好类型，不会影响运行效率。（所以C++是世界上编译速度最慢的语言（逃  

STL的很多方法的方法（成员函数）名称的命名会考虑到时间复杂度，比如各个容器的push_back()，pop_back()，push_front()等方法的时间复杂度都是O(1)的，这也是为什么容器vector不提供push_front()函数的原因，vector在头部插入的时间复杂度是O(n)的。所以在能用这类方法的时候就尽量不用insert()和erase()方法。  
还比如说，如果你需要频繁的在头尾操作元素，就应该选用容器list，需要频繁进行随机存取就应该使用vector。在合适的情况选择合适的容器。  

## 前置技能  
虽然说是前置技能，但是其实不需要怎么掌握也能用STL（逃  
但是我认为如果能够比较了解这些内容的话，可以更好的使用STL（但是只会一带而过的讲，如果之前语言基础不牢固还要去查其他资料）。

### 指针
指针在算法竞赛中能够使用到的地方真是少之又少，除了trie（字典树）等几个算法或数据结构外几乎都可以用其他方法替代（包括trie也是可以用数组模拟的）。  
除此之外的地方，指针也基本上可以被引用替代。  
不过还是举一个例子来看看指针在传参的用途，有兴趣的可以再去了解。   
```cpp
void swap(int* x, int* y)
{
  int temp = *x;
  *x = *y;
  *y = temp;
}
int main(void)
{
  int a = 1, b = 2;
  swap(&a, &b);
  cout<< a<< " "<< b<< endl;
  return 0;
}
```

输出结果： 2  1  

### 引用
其实引用能用到的地方也是很少了，在算法竞赛中。不过还是有，比如白书上扩展欧几里得算法的实现就用到了引用传参。那我们再来看看用引用怎么传参：  

```cpp
void swap(int& x, int& y)
{
  int temp = x;
  x = y;
  y = temp;
}
int main(void)
{
  int a = 1, b = 2;
  swap(a, b);
  cout<< a<< " "<< b<< endl;
  return 0;
}
```

输出结果： 2  1  

和指针传参效果一样，但是相比于用指针传递参数而言要方便很多。在要传占用内存较大的变量或类时可以用指针传递来加快效率。

### 运算符重载
你要是能在算法竞赛中遇到需要用运算符重载的情况的话，那真是撞大运了（其实就是也用的很少（逃。但是同前两个一样，在一些场合还是需要的。

- 高精度计算，这不是这篇要讲的东西（用Java去）
- 进行结构体或类的比较运算（比如你突发奇想打算在set里面装结构体）

运算符重载简而言之就是重新赋予C++原有的运算符新的意义。因为C++自带的类型有限，有时你需要去实现自定义的类或者结构体之间的运算。

让我们来看下面代码，我们需要将node以x为第一关键字，y为第二关键字按升序排序：  
```cpp
  struct node
  {
    int x;
    int y;
    bool operator < (const node& a) const
    {
      if (x < a.x)
        return true;
      else if (x == a.x && y < a.y)
        return true;
      return false;
    }
  };
  set <node> st;
int main(void)
{
  st.insert((node){2, 4}); //注意，这种写法是C++ 11添加的
  st.insert((node){1, 3});
  st.insert((node){2, 2});
  st.insert((node){1, 2});
  for (i: st)
    cout<< i.x<< " "<< i.y<< endl;
  return 0;
}
```

输出结果：  
1 1  
1 3  
2 2  
2 4  

除了这种方法外，大多数运算符还能重载到结构体或类的外部。  
比如，上面的运算符重载函数还能在node外写成：  
```cpp
bool operator < (const node& a, const node& b)
{
  if (a.x < b.x)
    return true;
  else if (a.x == b.x && a.y < b.y)
    return true;
  return false;
}
```
