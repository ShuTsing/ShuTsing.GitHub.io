---
layout:     post
title:      "日期星期转换——基姆拉尔森计算公式"
subtitle:   "Kim Larsson Calculation Formula"
date:       2018-03-21 21:24:00
author:     "ShuTsing"
header-img: "img/post-bg-35.jpg"
header-mask: 0.3
catalog:    true
tags:
    - 算法
---

最近做ACM练习题时做到了一道大模拟题 [Bovine Birthday](https://vjudge.net/contest/216992#problem/H)    
题目大概是给你日期让你算出是星期几。

连着两发没过，旁边女票看见后，给我支招了这个基姆拉尔森计算公式。

先列出公式：

**Week = (Day + 2 * Mon + 3 * (Mon + 1) / 5 + Year + Year / 4 - Year / 100 + Year / 400) mod 7**

其中：    
- 当年的一月和二月算作上一年的13月和14月

- 得到的结果：0表示星期一...6表示星期日

现在试着推导一下：

公元纪年法不存在公元0年，但是因为这里的计算是基于我们的时间是从0开始，所以我们现在假设公元0年存在，公元0年的1月1日为星期日

首先，对于最开始的7天，我们为了方便后续模运算，用0表示星期天，6表示星期六，则是：        
**Week = Day - 1**  (1

然后将其推广到一月，则是：    
**Week = (Day - 1) mod 7**  (2

我们假设每个月都是28天的话，那么每个月的公式都是公式2，但是由于几乎每个月都不止28天，所以我们需要对公式进行修正以消除误差

假设我们现在要推二月某日的星期，由于一月有31天，在计算时应该加3，则是：   
**Week = (Day - 1 + 3) mod 7**  (3

这3天的误差会累计到其他月份，并且，其他月份因为不是28天也会产生新的误差。    
在不考虑闰年的情况下，我们可以作出下面的误差表：  

月份 | 误差 | 累计误差 | mod 7
 :-: | :-: | :-: | :-:
 1 | 3 | 0 | 0
 2 | 0 | 3 | 3
 3 | 3 | 3 | 3
 4 | 2 | 6 | 6
 5 | 3 | 8 | 1
 6 | 2 | 11| 4
 7 | 3 | 13| 6
 8 | 3 | 16| 2
 9 | 2 | 19| 5
 10| 3 | 21| 0
 11| 2 | 24| 3
 12| - | 26| 5

12月后就没有月份了，所以12月产生的误差就不考虑了。

那么我们先用一个数组在装这些误差：    

**Err[] = {0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5}**

那么我们就可以对公式三进行修正：      
**Week = (Day - 1 + Err[Mon - 1] ) mod 7** (4

现在我们讲公式推广到年。     
在不考虑闰年的情况下，一年有365天，因为365 mod 7 = 1，所以，每一年的第一天和最后一天的星期是相同的，也就是下一年的第一天的星期比上一年的第一天的星期要多一。

这样，我们就可以将公式推广为：    
**Week = (Day - 1 + Err[Mon - 1] + Year) mod 7** (5

我们现在来讨论闰年，由于闰年要多1天，所以公式中需要计算从公元1年到当前年份经过了多少个闰年，根据闰年的判断公式，我们将公式修正为：    
**Week = (Day - 1 + Err[Mon - 1] + Year + (Year - 1) / 4 - (Year - 1) / 100 + (Year - 1) / 400) mod 7** (6

需要注意的是，这个公式这里并没有包含当年，也就是没有判断当年是否是闰年，这里根据求的月份是2月之前的还是2月之后的需要进行判断来决定是否+1天。

那么我们想一下，如果将当年的一月和二月当作上一年的13月和14月的话，就可以规避这种判断，在计算闰年时可以直接加上当年。

我们修正一下公式，同时修改一些误差表和基准，公元0年3月1日是星期三：

**Err[] = {0, 3, 5, 1, 3, 6, 2, 4, 0, 2, 5, 1}**

**Week = (Day + 2 + Err[Mon - 3] + Year + Year / 4 - Year / 100 + Year / 400) mod 7** (7

我们现在来看如何消除误差表，也就是找到一个函数关系，使得f(Mon) = Err[Mon - 3] (3 <= Mon <= 14)。

这种函数可以通过拼凑得出，现在直接写出这个函数：

**f(Mon) = (2 * Mon + 3 * (Mon + 1) / 5 - 1) mod 7**

我们现在用函数f替换误差表，得到公式：

**Week = (Day + 2 + 2 * Mon + 3 * (Mon + 1) / 5 - 1 + Year + Year / 4 - Year / 100 + Year / 400) mod 7** (8

整理，得：

**Week = (Day + 1 + 2 * Mon + 3 * (Mon + 1) / 5 + Year + Year / 4 - Year / 100 + Year / 400) mod 7** (9

我们现在将0-6从表示星期天到星期六改成表示星期一到星期日，则得到：

**Week = (Day + 2 * Mon + 3 * (Mon + 1) / 5 + Year + Year / 4 - Year / 100 + Year / 400) mod 7** (10

证毕。

事实上这个公式计算得到的日期的星期几是数学意义上的，格里高利历法去掉了1582年的10天的，英国历法去掉了1752年的11天，而且在格里高利历法之前，使用的是朱利安历法（儒略历法），导致这种计算方式并不能完全的推导出现实中的某些日期的星期。
