---
layout:     post
title:      "主席树（可持久化线段树）"
subtitle:   "Persistent Segment Tree"
date:       2018-07-26 11:42:00
author:     "ShuTsing"
header-img: "img/post-bg-21.jpg"
header-mask: 0.3
catalog:    true
tags:
    - 数据结构
    - 算法
---

## 引言

主席树，~~又称为伟大领袖树、红太阳树~~，学名叫做可持久化线段树，也可叫做函数式线段树。

为什么这玩意会叫主席树呢，据传说，这个数据结构是由一位名叫黄嘉泰的大佬发明的，黄嘉泰的拼音缩写为HJT，正好是某位国家领导人的拼音首字母缩写对吧（反正我博客是境外网站）。

![hjt](https://upload-images.jianshu.io/upload_images/13252077-d12ae0ff1d91090c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

而其叫函数式线段树是因为其用到了函数式编程的思想，对记录的数据只赋值不修改，每次插入一个数据后保存一个历史版本，然后利用线段树的结构完全相同，可以直接相减的特性进行区间询问。

## 回顾

主席树这玩意的学名既然叫做可持久化线段树，那么可以肯定，这玩意肯定是在线段树的基础上进行魔改的，具体来说，是权值线段树。

### 权值线段树

什么叫做权值线段树呢？？

对于我们普通的线段树，不管你是求sum，求max，还是求min，每个节点存放的都是那个节点对应的那段下标的sum、max或者min。

而权值线段树则是先进行离散化操作，每个节点存放的是区间内的数字出现的总次数。

举个例子来说明：

假设，我们有如下数组：

| IDX | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: |:-: | :-: | :-: | :-: |
| VALUE | 1 | 1 | 2 | 4 | 3 | 3 | 4 | 4 | 4 | 5 |

![vst](https://upload-images.jianshu.io/upload_images/13252077-f6910e75b004a97d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

节点(1, 1)存放的数组中1出现的次数，(2, 2)中存放的数组中2出现的次数，以此类推……

节点(1, 2)存放的1和2出现的次数的总和，以此类推……

上图所示的就是这样一颗权值线段树。

我们已经了解了权值线段树是什么了，那么我们现在来看看如下的问题：

>给出一个长度为n的序列和q次询问，每次询问这个序列的第k大元素是多大。   
>n, q∈[1, 1e5], ai∈[1, 1e9], k∈[1, n]

很显然，这道题可以将这个序列排序，然后每次查询即可，但是我们不用这个办法，我们用线段树怎么来解决这个问题呢？

我们对这个序列建立一颗权值线段树，假设是之前给出的序列，现在要找第7大的元素，那么先从根节点开始找，根节点为10，说明这个序列总共有10个，看左右节点的权值，左节点的值为9，说明序列中的前9小的数字都在左子树，那我们继续从这个节点开始找，那么这个节点的左节点是3，不行，那我们在其右节点寻找第7-3=4大的节点，再然后我们再在这个节点的右节点寻找第4-2=2大的节点，最终确定第k大的值是4。

## 正篇

我们的主席树学名叫做可持久化线段树，那么，什么叫做可持久化呢？就是字面的意思，能够保存并查阅历史版本。

那么我们的主席树就是一颗能够保存并查阅历史版本的线段树，什么意思呢？假设说，我们要想知道，在历史某一次操作之后的线段树是什么样子的，应该怎么办呢？

最简单的办法就是开多颗线段树，每进行一次操作就用一颗线段树保留下来。

不过很显然，这样操作下来，空间会炸，一颗线段树的空间已经不小了，现在还要开Q棵线段树，直接原地爆炸……

那么我们有没有什么能够减小空间的办法呢？

我们知道，我们对线段树的一次修改操作，最多只会修改一条链上最多logn个节点，这棵线段树的绝大部分节点都是没有修改的，那么，我们的新的一颗线段树，就可以只新开需要修改的节点，其他节点还是和上一棵线段树共用，这样空间占用就能小很多。

再回到区间第K大问题，我们刚刚用了一种很优秀的方法出色的解决了求区间1..n的第k大问题，那么我们把上述题目改一下：

>给出一个长度为n的序列和q次询问，每次询问这个序列中区间(l, r)的第k大元素是多大。   
>n, q, l∈[1, 1e5], r∈[l, n], ai∈[1, 1e9], k∈[1, l-r]

大体思路还是权值线段树，不过开一颗权值线段树肯定是不行的，那么我们要怎么来解决这个问题呢？

最先想到的是针对每个区间[l, r]都开一个线段树（大雾），这种想法可以pass掉了，稍微想一想也知道这个空间和时间复杂度怎么优化都没戏。

我们有没有办法只开n棵线段树呢，如果只开n棵线段树的话，时间和空间复杂度或许还能有救（逃。

我们思考一下，我们对于静态的求区间[l, r]的和的问题是怎么做的呢，是不是用的一种叫做前缀和的思想，先用一个数组sum[i]保存的区间[1, i]的总和，当我们求区间[l, r]的总和的时候，是不是用的sum[r] - sum[l-1]完成的呢。

那我们现在来看看有没有办法将前缀和的思想运用到这道题上来，这样我们就可以只构建n棵线段树了。

我们考虑一下，假设我们对于序列的每个下标i，都构建一颗表示区间[1, i]的权值线段树，那么，tree[r] - tree[l-1]是否能表示区间[l, r]的权值线段树呢？

我们知道，权值线段树的每个叶子节点i的表示的是数字i在其区间的出现次数，假设其在区间[1, l-1]出现x次，在区间[1, r]出现y次，那么，是不是其在区间[l, r]出现了y-x次呢，以此类推，我们可以发现，区间[l, r]的权值线段树是可以用区间[1, r]和区间[1, l-1]的权值线段树相减得到的。

这样我们将使用的线段树的数量减少到了n棵，但是n棵线段树的空间复杂度仍然太高，有没有办法减小其空间复杂度呢？

我们发现，我们在生成对于区间[1, i+1]的权值线段树的时候，只会修改区间[1, i]的权值线段树的一条链，那么我们可以利用到之前的可持久化的办法，这样我们新建一颗线段树，就只需要新开一条链的空间了。

我们现在解决了主席树的众多应用中最模板的一个了（笑














先挂着再说……
